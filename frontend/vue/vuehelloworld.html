<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue示例</title>

</head>
<body style="background-color:#244;color:#bbb;font-family:helvetica neue;">
    <div id = "app">
        <ul><li v-for="item in books">{{item.name}}</li></ul>
        <input type="text" v-model="name" placeholder="你的名字">
        <h4>你好，{{name}}</h4>
    </div>
<h3>_生命周期钩子</h3>
    <div id="container2"><span>{{animal}}</span></div>
<h3>_实时修改变量</h3>
    <div id="realTimeChangeVar">时间 date ：{{date}}</div>
<h3>v-html可用于展示html内容，{{}}会作为纯文本展示</h3>
    <div id="vhtmlusage"> <span v-html="link"></span> <br> <span>{{link}}</span>
<h3>v-pre可以跳过元素及其子元素的编译过程，显示<span v-pre>{{varName}}</span>而不进行替换</h3>
    </div>
<h3>{{这里可以进行一些简单的运算}}</h3>
    <div id="simpleCalcInMoustache">{{number/10}} {{isOk?'确定':'取消'}} {{text.split(',').reverse().join(',')}}</div>
<h2>Vue过滤器</h2>
<h3>Vue支持在{{}}插值的末尾添加一个管道符|进行数据过滤，常用于格式化文本等简单场景，如字母转大写、货币千位使用逗号分隔</h3>
  <div id="vueFilter">{{date|formatDate}}</div>
  <h4>过滤器支持串联和参数接收，如<span v-pre>{{message|filterA|filterB}}</span>...<span v-pre>{{messge|filterA('args1','args2')}</span></h4>
<h2>指令与事件</h2>
<h3>指令指带有v-前缀的Directives，指令的职责就是当其表达式的值改变时，相应地将某些行为应用到DOM上</h3>
<h3>v-if指令</h3>
  <a href="https://www.cnblogs.com/tangdrogn/p/9671913.html">emmet插件使用详解</a>
  <div id="vifShowElement"><span v-if="show">控制这段文本所在DOM是否展示</span><span>&emsp;好玩不？</span></div>
  <h4>数据驱动DOM是Vue.js的核心理念，所以DOM操作应当尽量交给Vue控制</h4>
<h3>v-bind指令</h3>
  <div id="vbindMVVM"><img v-bind:src="imgUrl"><br><a v-bind:href="url">链接</a></div>
<h3>v-on指令</h3>
  <div id="vonBindEventTest"><span v-if="show">胡子语法</span><button v-on:click="handleClose"><-点击隐藏</button><button v-on:click="show=false"><-点击隐藏[内联语句]</button></div>
  <h4>v-on支持的除了click外，还有dblclick、keyup、mousemove</h4>
<h3>语法糖</h3>
  <h4>v-bind可以省略为一个 :, v-on可以省略为一个 @ </h4>

<h2>第三章</h2>
<h3>计算属性</h3>
  <div id="calcProperty">{{reversedTextInCalcProperty}}</div>
  <div id="calcPropertySetterCustomize">计算属性自定义setter方法，在手动修改计算属性时会触发setter函数: {{funllname}}</div>
  <p>计算属性常被用于动态地设置元素的样式名称class和内联样式style，以及在使用组件的情况下动态传递props</p>
  <h4>计算属性还可以依赖其他计算属性；计算属性不仅可以依赖当前Vue实例数据，还可以依赖其他实例的数据</h4>
<h3>计算属性缓存</h3>
  <h4>computed可以使用methods取代，计算属性存在的原因是其缓存，一个计算属性所依赖的数据发生变化时，它才会重新取值。
  通常在遍历大数组和做大量计算时使用计算属性</h4>

<h2>第四章</h2>
<h3>绑定class的几种方式</h3>
  <h4>对象语法</h4>
  <p>如果isActive为true，下面会被渲染成 &lt;div :class='active'&gt;&lt;/div&gt;</p>
  <div id="bindClassByObjectGrammer"><div :class="{'active':isActive}"></div></div>
  <p>对象语法中传入的对象可以有多个属性,下面的渲染结果是class='static active'</p>
  <div id="bindClassWithMultiProps"><div class="static" :class="{'active':isActive,'error':isError}"></div></div>
  <p>上述对象语法可以改成计算属性的写法</p>
  <div id="bindClassByOrderInComputed"><div :class="classes"></div></div>
  <h4>数组语法</h4>
  <p>渲染后结果class="active error"</p>
  <div id="bindClassByArrayGrammer"><div :class="[activeClazz,errorClazz]"></div></div>
  <p>数组里放的是三目运算符,根据script里提供的数据，最终渲染为class="active,error"</p>
  <div id="bindClassByArrayGrammerWithTernaryOperator"><div :class="[isActive?activeCls:'',errorCls]"></div></div>
  <p>对象语法和数组语法还可以混用</p>
  <div id="bindClassByObjectPlusArrayGrammer"><div :class="[{'active':isActive}, errorCls]"></div></div>
  <h4>使用计算属性设置class</h4>
  <div id="bindClassByComputeProps"><button :class="classes">holdthedoor|holdthedoor</button></div>
  <h4>在组件上使用</h4>
  <p>最终组件会被渲染成 &lt;p class="article active"&gt;一些文本&lt;/p&gt;</p>
  <div id="bindClassOnCustomizedComponent"><my-component :class="{'active':isActive}"></my-component></div>
<h3>绑定内联样式</h3>
  <p>使用v-bind:style（简写作:style）可以给元素绑定内联样式，与:class类似，也有对象语法和数组语法</p>
  <p>CSS样式使用驼峰命名即可，浏览器会解析成横线‘-’连接的样式</p>
  <div id="bindStyle"><div :style="{'color':color,'fontSize':fontSize+'px'}">绑定内联样式</div></div>

<h2>第五章 内置指令</h2>
<h3>基本指令</h3>
  <h4>v-cloak不需要表达式，会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none;配合使用</h4>
  <div id="abountVCloak" v-cloak>{{message}}</div>
  <p>在网速较慢时，上面的胡子会显示在页面上，导致屏幕闪动，这时候可以使用一句CSS解决：[v-cloak]{display:none;}。一般情况下，v-cloak是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。但在工程化项目里，如使用npm webpack做管理的项目里，html结构只有一个空的div元素，剩余内容都是路由去挂载不同组件来完成，此时就不在需要v-cloak了</p>
  <h4>v-once也不需要表达式，作用是{{}}只会被渲染一次，后面内容不会被改变，通常用于优化性能，将动态内容作为静态内容处理</h4>
  <div id="abountVOnce"><span v-once>{{message}}</span></div>
<h3>条件渲染指令</h3>
  <div id="aboutVIfElse">
    <p v-if="status === 1">当status为1时显示这一行</p>
    <p v-else-if="status === 2">当status为2时显示第二行</p>
    <p v-else>其他情况显示此行</p>
  </div>
  <p>常用的部件可以使用template包装起来进行复用，下面的两个input在没有key元素时，输入内容后切换input发现先前输入的内容还在，添加key属性可以为每个input添加唯一标记，按类型复用，控制复用的范围</p>
  <div id="abountVIfElseInVueTemplateKey">
    <template v-if="type === 'name'">
      <label>用户名：</label>
      <input type="text" placeholder="输入用户名" key="name-input">
    </template>
    <template v-else>
      <label>邮箱：</label>
      <input type="text" placeholder="输入邮箱" key="mail-input">
    </template>
    <button @click="handleToggleClick">切换输入类型</button>
  </div>
  <p>v-show="true/false"表示是否展示DOM元素（添加内联样式display:none;）,v-show不能在template元素上使用。</p>
  <p>v-if与v-show对比</p>
  <p>两者都能切换元素的展示与隐藏；v-if是真正的条件渲染，会根据表达式决定DOM元素的重建和销毁，包括绑定的事件或子组件的处理，开销较大。v-show仅仅修改CSS样式，适合频繁展示隐藏切换的场景。</p>
<h3>列表渲染指令v-for</h3>
  <p>v-for也可以使用item of items,替换in，这是javascript语法。<br>遍历元素时book index的先后顺序不能颠倒</p>
  <div id="vForInTemplate"><ul>
    <template v-for="(book,index) in books">
      <li>编号：{{index+1}}书名：{{book.name}} 作者：{{book.author}}</li>
    </template>
    <button @click='toggleSort'>列表前端排序-按名称长度</button>
  </ul>
  <p>数组变异方法指的是会改变原数组内容的方法，如push pop shift unshift splice sort reverse.另外是不改变原数组而返回新数组的方法：filter、concat、slice
  <br>
  下述操作是不会触发试图更新的：1.通过索引设置元素 app.books[2]={...}; 2.修改数组长度 app.books.length=2;<br>
  设置元素可以使用vue的方法：Vue.set(app.books,3,{name:'...',author:'...'});
  修改数组长度可以使用splice实现：app.books.splice(2);
  </p>
  </div>
  <div id="vForeachPropInObject"><p>User对象的打印：</p><ul>
    <li v-for="(value,key,index) in user">第{{index+1}}个属性{{key}}的值是{{value}}</li>
  </ul></div>
  <div id="vForEachInteger"><span v-for='n in 10'>{{n}} </span></div>
</body>
<!--放在head中引入vue可以早一点初始化，避免{{}}被当作纯文本解析-->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
var app = new Vue({
    el: '#app', //el用于指定一个页面中已存在的DOM元素来挂载Vue实例，可以是HTMLElement, 也可以是CSS选择器
    //如 el:document.getElementById('app'); el:document.getElementById('#app')
    //可以通过app.$el来访问元素
    data: {
        books: [
            {name: 'java编程思想'},
            {name: 'javascript编程思想'},
            {name: 'js高级设计'}
        ],
        name: ' '
    }
});
var app2 = new Vue({
    el:'#container2',
    data:{animal:'cat'},
    created:function () {
        console.log('created函数： animal = ',this.animal)
        // console.log(this.animal);
    },
    mounted:function () {
        console.log(this.$el);//把id为app的div打印出来
    }
});
/*
//可以这样访问app对象里的属性
console.log(app.name);
//也可以将name绑定到下面的遍历namevar上，形成双向绑定，这样当namevar变化时，app中的name随之改变
var namevar = 'jack';
* */
var realTimeChangeVar = new Vue({
    el:'#realTimeChangeVar',
    data:{date:new Date()},
    mounted:function () {
        var _this = this;//声明一个变量指向Vue实例this，保证作用域一致
        this.timer = setInterval(function () {
            //todo 时间格式化
            _this.date = new Date();
        },1000);
    },
    beforeDestroy:function(){
        if (this.timer){
            clearInterval(this.timer);//在实例销毁前清除定时器
        }
    }
});
// $('#realTimeChangeVar')
var vhtmlusage = new Vue({
    el:'#vhtmlusage',
    data:{link:'<a href="#">这是一个链接</a>'}
});
var simpleCalcInMoustache = new Vue({
        el:'#simpleCalcInMoustache',
        data:{
            number:100, isOk:false, text:'天天向上,好好学习'
        }
    });
var padDateFormatFunction = function(value){
  return value<10?'0'+value:value;
}
var vueFilter = new Vue({
  el:'#vueFilter',
  data:{date:new Date()},
  filters:{
    formatDate:function(value){
      var date = new Date(value);
      var year = date.getFullYear();
      var month = padDateFormatFunction(date.getMonth()+1);
      var day = padDateFormatFunction(date.getDate());
      var hours = padDateFormatFunction(date.getHours());
      var minutes = padDateFormatFunction(date.getMinutes());
      var seconds = padDateFormatFunction(date.getSeconds());
      return year+'-'+month+'-'+day+' '+hours+':'+minutes+':'+seconds;
    }
  },
  mounted:function(){
    var _this = this;//声明一个变量指向vue实例this，保证作用域一致
    this.timer = setInterval(function(){
      _this.date = new Date();//每过1秒修改date数据
    },1000);
  },
  beforeDestroy:function() {
    if (this.timer) {
      clearInterval(this.timer);//实例销毁前清除timer
    }
  }
});
var vifShowElement = new Vue({
  el:'#vifShowElement',
  data:{show:false},
  mounted:function(){
    var _this = this;
    this.timer = setInterval(function(){
      _this.show = _this.show?false:true;
    },2000)
  },
  beforeDestroy:function(){
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
});
var vbindMVVM = new Vue({
  el:'#vbindMVVM',
  data:{
    imgUrl:'https://www.baidu3.com/img/flexible/logo/pc/result.png',
    url:'www.savewaterwhite.com'
  }
});
var vonBindEventTest = new Vue({
  el:'#vonBindEventTest',
  data:{show:true},
  methods:{
    handleClose:function(){
      this.show = this.show?false:true;
    }
  }
});
// vonBindEventTest.handleClose(); 可以这样调用方法
// 第三章
var calcProperty = new Vue({
  el:'#calcProperty',
  data:{
    text:'天天向上,好好学习',
  },
  computed:{
    reversedTextInCalcProperty:function(){
      return this.text.split(',').reverse().join('，');
    }
  }
});
var calcPropertySetterCustomize = new Vue({
  el:'#calcPropertySetterCustomize',
  data:{firstname:'jack', lastname:'goodman'},
  computed:{
    funllname:{
      get:function(){//这是vue里的getter方法
        return this.firstname+' '+this.lastname;
      },
      //执行calcPropertySetterCustomize.fullname = 'saul goodman'时，setter方法会被调用
      set:function(newname){
        var names = newname.split('.');
        this.firstname = names[0];
        this.lastname = names[names.length - 1];
      }
    }
  }
});
//第四章
var bindClassByObjectGrammer = new Vue({
  el:'#bindClassByObjectGrammer',
  data:{isActive:true}
});
var bindClassWithMultiProps = new Vue({
  el:'#bindClassWithMultiProps',
  data:{isActive:true,isError:false}
});
var bindClassByOrderInComputed = new Vue({
  el:'#bindClassByOrderInComputed',
  data:{isActive:true,error:false},
  computed:{
    classes:function(){
      return {
        active:this.isActive&&!this.error
      }
    }
  }
});
var bindClassByArrayGrammer = new Vue({
  el:'#bindClassByArrayGrammer',
  data:{
    activeClazz:'active',errorClazz:'error'
  }
});
var bindClassByArrayGrammerWithTernaryOperator = new Vue({
  el:'#bindClassByArrayGrammerWithTernaryOperator',
  data:{isActive:true,activeCls:'active',errorCls:'error'}
});
// 这个vue实例最终会把button渲染为 class="btn btn-large btn-disabled"
var bindClassByComputeProps = new Vue({
  el:'#bindClassByComputeProps',
  data:{size:'large',disabled:true},
  computed:{
    classes:function(){
      return ['btn',{['btn-'+this.size]:this.size != '',['btn-disabled']:this.disabled}]
    }
  }
});
Vue.component('my-component',{
  template:'<p class="article">一些文本</p>'
});
var bindClassOnCustomizedComponent = new Vue({
  el:'#bindClassOnCustomizedComponent',
  data:{isActive:true}
});
var bindStyle = new Vue({
  el:'#bindStyle',
  data:{color:'green',fontSize:16}
});
//第五章
var abountVCloak = new Vue({
  el:'#abountVCloak',
  data:{message:null,message_future:'延迟加载的文本'},
  mounted:function(){
    var _this = this;
    this.timer = setTimeout(function(){
      _this.message = _this.message_future;
    },3000);
  },
  beforeDestroy:function(){
    if (this.timer) {
      clearTimeout(this.timer);
    }
  }
});
var abountVOnce = new Vue({
  el:'#abountVOnce',data:{message:'只能渲染一次'},
  mounted:function(){
    var _this = this;
    this.timer = setTimeout(function(){
      _this.message = "改变vonce文字";
    },3000);
  },
  beforeDestroy:function(){
    if (this.timer) {
      clearTimeout(this.timer);
    }
  }
});
var aboutVIfElse = new Vue({
  el:'#aboutVIfElse',
  data:{status:1},
  mounted:function(){
    var _this = this;
    this.timer = setInterval(function(){
      _this.status = (_this.status+1)%3;
      // console.log('aboutVIfElse: status = '+_this.status);
    },5000);
  },
  beforeDestroy:function(){if (this.timer) {clearInterval(this.timer);}}
});
var abountVIfElseInVueTemplateKey = new Vue({
  el:'#abountVIfElseInVueTemplateKey',
  data:{type:'name'},
  methods:{
    handleToggleClick:function(){
      this.type = this.type === 'name'?'mail':'name';
    }
  }
});
var vForInTemplate = new Vue({
  el:'#vForInTemplate',
  data:{books:[{name:'《vue实战》',author:'梁灏'},{name:'《java编程思想》',author:'jack'},{name:'《算法导论》',author:'hisenberge'}],isSorted:false},
  methods:{
    toggleSort:function(){
      console.log("排序了");
      this.books.push({name:'geek',author:'park'});
      this.books = this.books.sort(function(a,b){return a.name.length < b.name.length});
    },
    toggleFilter:function(){
      this.books.filter(function(item){
        return item.name.match(/java/);
      });
    }
}
});
vForInTemplate.books.push({name:'《中央帝国的三大密码》',author:'作家'});
var vForeachPropInObject = new Vue({
  el:'#vForeachPropInObject',
  data:{user:{name:'jack',age:12,address:'newyork'}}
});
//vue实例必须要生成，否则不会进行渲染
var vForEachInteger = new Vue({el:'#vForEachInteger'});
</script>
</html>
